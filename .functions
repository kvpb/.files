#!/usr/bin/env bash

mf ()
{
	for var in "$@";
	do
		if [ -e "${var}" ];
		then
			printf "${var}: file exists\n";
		else
			> "${var}";
			printf '\n' >> ${var};
			#printf "${var}\n"; # To do for version 2.0: Write a verbose mode called by inputting {,-,--}v{,erbose} as the first argument, grouping files by created files or existing ones, separating files of the same type by tabs and types of files by newlines and writing a newline at the end of the script.
		fi;
	done;
} # mf, mkfl, mkfil
# mf	make files
# touch tempers with the timestamps. mkfile does not create empty files. Sometimes, that's all you need.

#md ()
#{
#} # md, mkdr, mkdire
# md	make directories

mcd ()
{
	mkdir -p "$@" && cd "$_";
}
# mcd	make directories, and change the shell working directory to it

#dl ()
#{
#	;
#} # dl, del, delete
# del	delete file or directory
# The del function deletes any file of any type.

te ()
{
	for var in "$@";
	do
		if [ -e "${var}" ];
		then
			return 1;
		else
			return 0;
		fi;
	done;
} # te, tef, tedir, tedev
# te	there exists
# The te function checks whether files exist.

lt ()
{
	printf '%s  ' {,.}*;
} # lt	builtin-only ls, the ls substitute from built-in commands

ll ()
{
	pwd && ls -@aeFGlT;
} # ll	locate, and extendedly list all directory contents

cls ()
{
	printf '\033[2J\033[3J\033[1;1H';
}
# cls	builtin-only MS-DOS, OS/2 & Microsoft Windows CLS: Clear the terminal screen if this is possible, then write the VT100 escape code for resetting the terminal to the standard output under the control of the format.

dcal ()
{
	date | grep -C6 --color "\b$(date +%e)\b" && cal | sed -n "1!p" | grep -C6 --color "\b$(date +%e)\b";
}
# dcal	dated calendar: Display a calendar, substitute month of year with current date in full format, and highlight current day of month.

ne ()
{
	for file in "$@";
	do
		if [ "$(tail -c 1 "${file}" | wc -l)" -eq 0 ];
		then
			printf '\n' >> ${file};
		else
			:
		fi;
	done;
} # ne, nfeol, writemissingnlateof
# ne	write NL at EOF
# The nae function inserts a newline after the pre-end-of-file line if that latter is not empty.

rn ()
{
	number=${RANDOM};
	nombre=${RANDOM};
	index=$[RANDOM%5+1];
#	operator=( "arithmetic" "in-de-crement" "relational" "logical" "conditional" "assignment" "bitwise" "miscellaneous" );
#		operator[1]=( "" "+" "-" "*" "/" "%" 0 );
	operator[0]='';
	operator[1]='+';
	operator[2]='-';
	operator[3]='\*';
	operator[4]='/';
	operator[5]='%%'; # `%%` is a printf-only percent sign escaping.
	expression="${number} ${operator[${index}]} ${nombre}"; #printf "${index}\tdebug\n${expression}\tdebug\n";

#	number=$RANDOM; character="+"; string="$number ${character} $number"; echo $number && echo ${character} && expr $(echo ${string}) # V [It works, but I want it to randomly pick an operator.]
#	n=$RANDOM; c=( "" "+" "-" "*" "/" "%" ); s="${n} ${c[$[RANDOM%5+1]]} ${n}"; echo $n && echo ${c} && expr ${s} # X [It fucks up. Apparently, the curly braces around number variables in the string variable cause it to fail. I guess I should understand how brace expansion works.]
#	n=$RANDOM; i=$[RANDOM%5+1]; c=( "" "+" "-" "*" "/" "%" ); s="$n ${c[$i]} $n"; echo $n && echo $i && echo ${c} && expr ${s} # x [It works better, but it does not work well when it picks the multiplicator, the divider or the modulo. ..just l qualiter]
#	n=$RANDOM; i=$[RANDOM%3+1]; c=( "" "+" "-" "*" "/" "%" ); s="$n ${c[$i]} $n"; echo $n && echo $i && echo ${c} && expr ${s} # v [It still shits up when it picks the multiplication operator, saying 'expr: syntax error'. If I entered it manually, I would escape the multiplication operator. Unfortunately, whether I escape it in the operators array or in the string variable, I still get that error.]
	if [ ${index} -eq 0 -o ${index} -eq 3 ];
	then
		expr ${number} \* ${nombre};
	else
		expr $(printf "${expression}");
	fi;
#	expr ${number} ${operator[${index}]} ${nombre}; # [... Which, I recall, is exactly what I tried first back in the days. The multiplication and modulo operators keep failing no matter what. I still wonder why I limited the selection to the three first operators... According to printf's output, I was right all along since the beginning: it does not select the first of the array, it chooses one of the five operators, and it fails to work with the multiplicator and the modulo. You'd shit twenty bucks of Quick, it'd still look fabulous next to this mess. Lord almighty.]
} # rn, randomnumber
# rn	output random numbers
# The rn function computes a pseudorandom number then prints it.

ru ()
{
	username='usr';
	number=$[RANDOM%9999+1];

	printf "${username}${number}\n";
} # ru, run, randomusername
# ru	output random usernames

# Mac Shell Functions

MakeFinderAlias ()
{
	local Location=$(\pwd);
	local File=$1;
	local Folder=$2;

	if [[ "${File}" == /* ]] && [[ "${Folder}" == /* ]];
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${File//\"/\\\"}\") at (POSIX file \"${Folder//\"/\\\"}\")" -e 'return';
	elif [[ "${File}" == /* ]] && [[ ! "${Folder}" == /* ]];
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${File//\"/\\\"}\") at (POSIX file \"${Location}/${Folder//\"/\\\"}\")" -e 'return';
	elif [[ ! "${File}" == /* ]] && [[ "${Folder}" == /* ]];
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${Location}/${File//\"/\\\"}\") at (POSIX file \"${Folder//\"/\\\"}\")" -e 'return';
	elif [[ ! "${File}" == /* ]] && [[ ! "${Folder}" == /* ]];
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${Location}/${File//\"/\\\"}\") at (POSIX file \"${Location}/${Folder//\"/\\\"}\")" -e 'return';
	fi;
} # mfa, mkfras, MakeFinderAlias
# 2018.04.18, 17:04:00 : Ça doit être la shell function la plus dégueulasse que j'ai écrit. It doesn't handle any and all relative paths. I don't care anyway. I've been jacking with this stuff almost all afternoon.

DeleteDSStore ()
{
	find . -name '.DS_Store' -delete -print
} # ds, dds, ddss, deletedsstore, DeleteDSStore
# DeleteDSStore	.DS_Store Files Deletion: Find from the current directory any file named .DS_Store, remove it, and display the full file name of the standard output followed by a newline.

ResetLaunchPad ()
{
	defaults write com.apple.dock ResetLaunchPad -boolean TRUE && killall Dock;
} # rlp, resetlaunchpad, ResetLaunchPad
# ResetLaunchPad	LaunchPad Reset
# The ResetLaunchPad function resets the LaunchPad's layout.

# Specific-Use Functions

tqdc ()
{
	local prefix=$1;
	local suffix=$2;

	find * -maxdepth 0 -type d -exec tar cvf $prefix{}$suffix.tar {} \;
} # tqdc, tarqdlc, tapearchiveQobuzdownloadedcontent
# tqdc	Qobuz downloaded content tape-archival: Create a new tape archive for each of the working directory's subdirectories.



# function () {
# 	;
# } # FUNCTIONNAME, FUNCTIONNAMEn
# # MANPAGENAME
# # MANPAGESYNOPSIS
# # MANPAGEDESCRIPTION
# # PERSONALCOMMENT
