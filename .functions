#!/usr/bin/env sh

mf()
{
	for var in "${@}";
	do
		if [ -e "${var}" ];
		then
			printf "${var}: file exists\n";
		else
			:> "${var}";
			printf '\n' >> ${var};
		fi;
	done;
}; # mf, mkfl, makefiles
# mf	make files
# touch tempers with the timestamps. mkfile does not create empty files. Sometimes, that's all you need.

ne()
{
	for file in "${@}";
	do
		if [ "$(tail -c 1 "${file}" | wc -l)" -eq 0 ];
		then
			printf '\n' >> ${file};
		else
			:
		fi;
	done;
}; # ne, nfeol, writemissingNLatEOF
# ne	write NL at EOF
# The nae function inserts a newline after the pre-end-of-file line if that latter is not empty.

#md()
#{
#}; # md, mkdr, makedirectories
# md	make directories

ms()
{
	S="${1}";

	python -c "import os, socket as s; s.socket(s.AF_UNIX).bind(os.environ['S'])";
}; # ms, mksock, makesockets
# ms	make sockets
# https://serverfault.com/a/914572

mcd()
{
	mkdir -p "${@}" && cd "${_}";
}; # mcd, makeandchangedirectory
# mcd	make directories, and change the working directory to it

#dl()
#{
#	;
#}; # dl, del, delete
# del	delete file or directory
# The del function deletes any file of any type.

function st
{
	A=(${@})
	s=${IFS}
	IFS=' ' #IFS=$'\n'
	S=($(sort <<< "${A[*]}"))
	IFS=${s}; #unset IFS;
	printf '%s\n' "${S}"
} # st	sort

function rb
{
	i=1;

	if [ ${#} -eq 0 ]; #if [ -z "${@:${i}:1}" ];
	then
		irb;
	else
		ruby ${@:${i}};
	fi;
}

sqlite3-dump()
{
	pathname=${1};

	sqlite3 "${pathname}" -cmd ".dump" "";
}; # sql, sqld, sqlite3-dump
# sqlite3-dump	dump the database in an SQL text format

pn()
{
	printf "$(cd "$(dirname "${1}";)" && pwd -P;)/$(basename "${1}";)"'\n'; #echo $(cd "$(/usr/bin/dirname "${1}")" && pwd -P)/$(/usr/bin/basename "${1}");
}; # pn, pathname
# pn	return pathname

lt()
{
	printf '%s\n' {.{.?,[^.]},}*; #{..?*,.[^.]*,*}; #if [ $(printf $(f() { printf ${#}; } && f $(printf "%s${IFS}" .[^.]*;););) -gt 1 -a $(printf $(f() { printf ${#}; } && f $(printf "%s${IFS}" .[^*]*;););) -gt 1 ]; then printf '%s\n' {.{.?,[^.]},}*; else
}; # lt, list
# lt	builtin-only ls, the ls substitute from built-in commands

if ! ls -@eT > /dev/null 2>&1
then
	ll()
	{
		pwd && ls -aFGl;
	};
else
	ll()
	{
		pwd && ls -@aeFGlT;
	};
fi; # ll, listlongly
# ll	locate, and extendedly list all directory contents

pv()
{
	( set -o posix && set ); #( set -o posix; set ) | less; # '(list)    list  is  executed  in  a  subshell  environment (see COMMAND EXECUTION ENVIRONMENT below).' man bash
}; # pv, printvar, printvariables
# pv	print variables

function ae
{
	local A=("${@}"); #array= #E= #expression=
	readonly A;
	local s="${A[*]}"; #string= #E= #expression=
	readonly s;
	local i; #integer= #E= #evaluation=

	(( i = ${s} )); #i=$(( ${s} ));
	printf "%d\n" ${i};
}; # ae, arithmeticevaluation
# ae	builtin-only expr, the expr substitute from built-in commands

rn()
{
	number=${RANDOM};
	nombre=${RANDOM};
	index=$[RANDOM%5+1];
	operator[0]='';
	operator[1]='+';
	operator[2]='-';
	operator[3]='\*';
	operator[4]='/';
	operator[5]='%%'; # `%%` is a printf-only percent sign escaping.
	expression="${number} ${operator[${index}]} ${nombre}"; #printf "${index}\tdebug\n" && printf "${expression}\tdebug\n";

	if [ ${index} -eq 0 -o ${index} -eq 3 ];
	then
		expr ${number} \* ${nombre};
	else
		expr $(printf "${expression}";);
	fi;
}; # rn, randomnumber
# rn	output random numbers
# The rn function computes a pseudorandom number then prints it.

ru()
{
	username='usr';
	number=$[RANDOM%9999+1];

	printf "${username}${number}"'\n';
}; # ru, run, randomusername
# ru	output random usernames

dcal()
{
	date | grep --context=6 --color "\b$(date +%e)\b" && cal | sed -n '1!p' | grep --context=6 --color "\b$(date +%e)\b";
};
# dcal	dated calendar: Display a calendar, substitute month of year with current date in full format, and highlight current day of month.

cls()
{
	printf '\033[2J\033[3J\033[1;1H';
}; # cs, cls, clearscreen
# cls	builtin-only MS-DOS, OS/2 & Microsoft Windows CLS: Clear the terminal screen if this is possible, then write the VT100 escape code for resetting the terminal to the standard output under the control of the format.

# Mac Shell Functions

MakeFinderAlias()
{
	local Location=$(\pwd;);
	local File=${1};
	local Folder=${2};

	if [[ "${File}" == /* ]] && [[ "${Folder}" == /* ]];
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${File//\"/\\\"}\") at (POSIX file \"${Folder//\"/\\\"}\")" -e 'return';
	elif [[ "${File}" == /* ]] && [[ ! "${Folder}" == /* ]];
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${File//\"/\\\"}\") at (POSIX file \"${Location}/${Folder//\"/\\\"}\")" -e 'return';
	elif [[ ! "${File}" == /* ]] && [[ "${Folder}" == /* ]];
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${Location}/${File//\"/\\\"}\") at (POSIX file \"${Folder//\"/\\\"}\")" -e 'return';
	elif [[ ! "${File}" == /* ]] && [[ ! "${Folder}" == /* ]];
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${Location}/${File//\"/\\\"}\") at (POSIX file \"${Location}/${Folder//\"/\\\"}\")" -e 'return';
	fi;
}; # mfa, mkfras, MakeFinderAlias
# MakeFinderAlias	make Finder aliases
# The MakeFinderAlias function makes Finder aliases.

DeleteDSStore()
{
	find . -name '.DS_Store' -delete -print; #find . -mindepth 0 -maxdepth 1 -name '.DS_Store' -delete -print;
}; # ddss, DeleteDSStore
# DeleteDSStore	.DS_Store Files Deletion: Find from the current directory any file named .DS_Store, remove it, and display the full file name of the standard output followed by a newline.

ResetLaunchPad()
{
	defaults write com.apple.dock ResetLaunchPad -boolean TRUE && killall Dock;
}; # rlp, ResetLaunchPad
# ResetLaunchPad	LaunchPad Reset
# The ResetLaunchPad function resets LaunchPad's layout.

GetBundleID()
{
	for i in ${#@}; do local A[${i}]=$(find /{,System/,/Users/${USER}/}Applications -mindepth 1 -maxdepth 1 -type d -iname ${i}); done;

	for i in ${A};
	do
		/usr/libexec/PlistBuddy -c 'Print CFBundleIdentifier' ${i}/Contents/Info.plist; #osascript -e 'ID of app "${i}"';
	done;
};

# Specific-Use Functions

tqdc()
{
	local s_1="${1}"; #prefix=
	readonly s_1;
	local s_2="${2}"; #suffix=
	readonly s_2;
	local s_3="tar"; #extension=
	readonly s_3;
	#local s_0="${s_1}'{}'${s_2}.${s_3}"; #filename= # Although POSIX-compliant shells, e.g. BSH, KSH, ASH, do not particularly interpret {}, FISH does, so quote it.

	find * -maxdepth 0 -type d -exec tar -v -c -f "${s_1}"'{}'"${s_2}"'.tar' {} \;; #find * -maxdepth 0 -type d -exec tar vcf "${s_0}" {} \;;
}; # tqdc, tarqdlc, tapearchiveQobuzdownloadedcontent
# tqdc	Qobuz downloaded content tape-archival: Create a new tape archive for each of the working directory's subdirectories.

#fn()
#{
#	;
#}; # FUNCTIONNAME, FUNCTIONNAMEn
# # MANPAGENAME
# # MANPAGESYNOPSIS
# # MANPAGEDESCRIPTION
# # PERSONALCOMMENT
