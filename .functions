#!/usr/bin/env bash

DeleteDSStore ()
{
	find . -name '.DS_Store' -delete -print
} # `DeleteDSStore` '.DS_Store Deletion'
# Find from current directory file named '.DS_Store', remove it, and display the full file name of the standard output followed by a newline.

ResetLaunchPad ()
{
	defaults write com.apple.dock ResetLaunchPad -bool true && killall Dock
} # `ResetLaunchPad` 'LaunchPad Reset'
# Reset LaunchPad layout.

tapearchiveQobuzdownloadedcontent ()
{
	local prefix=$1
	local suffix=$2

	find * -maxdepth 0 -type d -exec tar cvf $PREFIX{}$SUFFIX.tar {} \;
} # `tapearchiveQobuzdownloadedcontent` 'Qobuz downloaded content tape-archival'
# Create a new tape archive for each of the working directory's subdirectories.

dcal ()
{
	date | grep -C6 --color "\b$(date +%e)\b" && cal | sed -n "1!p" | grep -C6 --color "\b$(date +%e)\b"
} # `dcal` 'Dated Calendar'
# Display a calendar, substitute month of year with current date in full format, and highlight current day of month.

cls ()
{
	clear && printf '\e[3J'
} # `cls` 'MS-DOS, OS/2 & Microsoft Windows CLS'
# Clear the terminal screen if this is possible, then write the VT100 escape code for resetting the terminal to the standard output under the control of the format.

updatesystemsoftware ()
{
	sudo softwareupdate -i -a
	brew update && brew upgrade && brew cleanup
	sudo gem update --system && sudo gem update && sudo gem cleanup
} # `updatesystemsoftware` 'Sony System Software Update'
# List all available updates, and install them ; fetch the newest version of Homebrew, upgrade outdated, unpinned brews, and remove any installed formulae older version from the cellar ; update installed gems to the latest versions, and clean up old versions of installed gems.

writemissingNLatEOF ()
{
	sed -i '' -e '$a\'
} # `add_missing_NL_at_EOF` 'Add missing newline at end of file', from Victor Engmark `l0b0`'s `empty_line_before_eof` (https://github.com/l0b0/tilde/blob/e7ccc9a6a3aba2b0216c8e5141554e8a729389ec/.bash_aliases#L474)
# Insert a newline after pre-end of file line if that latter is not empty.

MakeFinderAlias ()
{
	local Location=$(\pwd)
	local File=$1
	local Folder=$2

	if [[ "${File}" == /* ]] && [[ "${Folder}" == /* ]]
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${File//\"/\\\"}\") at (POSIX file \"${Folder//\"/\\\"}\")" -e 'return'
	elif [[ "${File}" == /* ]] && [[ ! "${Folder}" == /* ]]
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${File//\"/\\\"}\") at (POSIX file \"${Location}/${Folder//\"/\\\"}\")" -e 'return'
	elif [[ ! "${File}" == /* ]] && [[ "${Folder}" == /* ]]
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${Location}/${File//\"/\\\"}\") at (POSIX file \"${Folder//\"/\\\"}\")" -e 'return'
	elif [[ ! "${File}" == /* ]] && [[ ! "${Folder}" == /* ]]
	then
		osascript -e "tell application \"Finder\" to make alias file to (POSIX file \"${Location}/${File//\"/\\\"}\") at (POSIX file \"${Location}/${Folder//\"/\\\"}\")" -e 'return'
	fi
} # `MakeFinderAlias`
# Make Finder aliases. [2018.04.18, 17:04:00 : Ça doit être la shell function la plus dégueulasse que j'ai écrit. It doesn't handle any and all relative paths. I don't care anyway. I've been jacking with this stuff almost all afternoon.]

computerandomnumber ()
{
	number=$RANDOM;
	index=$[RANDOM%3+1];
#	operator=( "arithmetic" "in-de-crement" "relational" "logical" "conditional" "assignment" "bitwise" "miscellaneous" );
#		operator[1]=( "" "+" "-" "*" "/" "%" 0 );
	operator[0]="";
	operator[1]="+";
	operator[2]="-";
	operator[3]="*";
	operator[4]="/";
	operator[5]="%";
	expression="$number ${operator[$index]} $number";

#	number=$RANDOM; character="+"; string="$number ${character} $number"; echo $number && echo ${character} && expr $(echo ${string}) # V [It works, but I want it to randomly pick an operator.]
#	n=$RANDOM; c=( "" "+" "-" "*" "/" "%" ); s="${n} ${c[$[RANDOM%5+1]]} ${n}"; echo $n && echo ${c} && expr ${s} # X [It fucks up. Apparently, the curly braces around number variables in the string variable cause it to fail. I guess I should understand how brace expansion works.]
#	n=$RANDOM; i=$[RANDOM%5+1]; c=( "" "+" "-" "*" "/" "%" ); s="$n ${c[$i]} $n"; echo $n && echo $i && echo ${c} && expr ${s} # x [It works better, but it does not work well when it picks the multiplicator, the divider or the modulo. ..just l qualiter]
#	n=$RANDOM; i=$[RANDOM%3+1]; c=( "" "+" "-" "*" "/" "%" ); s="$n ${c[$i]} $n"; echo $n && echo $i && echo ${c} && expr ${s} # v [It still shits up when it picks the multiplication operator, saying 'expr: syntax error'. If I entered it manually, I would escape the multiplication operator. Unfortunately, whether I escape it in the operators array or in the string variable, I still get that error.]
	expr $(echo ${expression});
}

generaterandomusername ()
{
	username='usr'
	number=$[RANDOM%9999+1]

	echo "${username}${number}"
} # `GenerateRandomUsername`
# Generate a random username.
